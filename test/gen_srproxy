#!/usr/bin/env python

# This script is intended to be compatible with both python2 and python3
from __future__ import print_function

import pygccxml

import argparse
import os
import sys

# Don't spam pygccxml deprecation warnings
import warnings
warnings.simplefilter(action = 'once', category = DeprecationWarning)

# Globals
fcxx = None
fhdr = None
ffwd = None

# Extra member functions for specfic classes.
class_to_addons = {}


def friendly_name(klass):
    if gFlat:
        return 'Flat'+klass.name
    else:
        return klass.name+'Proxy'

# Drop the allocator argument from vectors
def short_type(type):
    if not is_vector(type):
        if hasattr(type, 'name'): return full_name(type)
        return str(type)

    inner = vector_contents(type)
    if is_vector(inner): inner = short_type(inner)
    if pygccxml.declarations.is_class(inner): inner = full_name(inner)
    return 'std::vector<'+str(inner)+'>'


def full_namespace(type):
    ns = []
    while type.parent and type.parent.name != '::':
        ns = [type.parent.name]+ns
        type = type.parent
    return '::'.join(ns)


def full_name(type):
    return full_namespace(type)+'::'+type.name


def members(klass):
    # Only accept direct members. Sort to keep .cxx and .h consistent
    return sorted([v for v in klass.variables(allow_empty = True) if v.parent == klass and not v.type_qualifiers.has_static])


def base_class(klass):
    assert len(klass.bases) < 2, 'Support for multiple base classes not implemented'
    if len(klass.bases) == 1:
        return klass.bases[0].related_class
    return None


def is_template(type):
    return pygccxml.declarations.templates.is_instantiation(str(type))


def is_vector(type):
    if not is_template(type): return False

    return pygccxml.declarations.templates.name(str(type)) == 'std::vector'


def vector_contents(type):
    assert is_vector(type)

    return pygccxml.declarations.container_traits.vector_traits.element_type(type)

def array_contents(type):
    assert pygccxml.declarations.is_array(type)

    # This is the answer, except for some reason it can be a stupid
    # declarated_t
    ret = pygccxml.declarations.type_traits.array_item_type(type)

    if (pygccxml.declarations.type_traits.is_fundamental(ret) or
        pygccxml.declarations.is_array(ret)):
        return ret

    # So we sometimes have to do this clumsy dance to concert it back to a real
    # class
    return global_ns.class_(ret.decl_string, recursive = True)

def proxy_type(type):
    if gFlat:
        return 'flat::Flat<'+short_type(type)+'>'
    else:
        return 'caf::Proxy<'+short_type(type)+'>'

# -----------------------------------------------------------------------------
def disclaimer():
    return '''// This file was auto-generated by SRProxy's gen_srproxy.
// DO NOT EDIT IT DIRECTLY.'''

# -----------------------------------------------------------------------------
proxy_hdr_prolog = '''{DISCLAIMER}

#pragma once

{PROLOG}
#include "SRProxy/BasicTypesProxy.h"

#include "{OUTPATH}/FwdDeclare.h"

'''

flat_hdr_prolog = '''{DISCLAIMER}

#pragma once

{PROLOG}
#include "SRProxy/FlatBasicTypes.h"

#include "{OUTPATH}/FwdDeclare.h"

'''

def hdr_prolog():
    return flat_hdr_prolog if gFlat else proxy_hdr_prolog

# -----------------------------------------------------------------------------
proxy_hdr_body = '''
/// Proxy for \\ref {TYPE}
template<> class {PTYPE}{BASE}
{{
public:
  Proxy(TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(TTree* tr, const std::string& name) : Proxy(tr, name, kDummyBase, 0) {{}}
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const {TYPE}& x);

  void CheckEquals(const {TYPE}& sr) const;
{ADDONS}
{MEMBERS}
}};
'''

flat_hdr_body = '''
/// Flat encoding of \\ref {TYPE}
template<> class {PTYPE}{BASE}
{{
public:
  Flat(TTree* tr, const std::string& prefix, const std::string& totsize, const IBranchPolicy* policy);

  void Fill(const {TYPE}& sr);
  void Clear();

protected:
{ADDONS}
{MEMBERS}
}};
'''

def hdr_body():
    return flat_hdr_body if gFlat else proxy_hdr_body

# -----------------------------------------------------------------------------
proxy_cxx_prolog = '''{DISCLAIMER}

#include "{HEADER}"

#include "{INPUT}"

namespace
{{
  std::string Join(const std::string& a, const std::string& b)
  {{
    if(a.empty()) return b;
    return a+"."+b;
  }}
}}
'''

flat_cxx_prolog = '''{DISCLAIMER}

#include "{HEADER}"

#include "{INPUT}"
'''

def cxx_prolog():
    return flat_cxx_prolog if gFlat else proxy_cxx_prolog

# -----------------------------------------------------------------------------
proxy_cxx_body = '''
{PTYPE}::Proxy(TTree* tr, const std::string& name, const long& base, int offset) :
{INITS}
{{
}}

{PTYPE}& {PTYPE}::operator=(const {TYPE}& sr)
{{
{ASSIGN_BODY}
  return *this;
}}

void {PTYPE}::CheckEquals(const {TYPE}& sr) const
{{
{CHECKEQUALS_BODY}
}}
'''

flat_cxx_body = '''
{PTYPE}::Flat(TTree* tr, const std::string& prefix, const std::string& totsize, const IBranchPolicy* policy) :
{INITS}
{{
}}

void {PTYPE}::Fill(const {TYPE}& sr)
{{
{FILL_BODY}
}}

void {PTYPE}::Clear()
{{
{CLEAR_BODY}
}}
'''

def cxx_body():
    return flat_cxx_body if gFlat else proxy_cxx_body

# -----------------------------------------------------------------------------
proxy_fwd_prolog = '''{DISCLAIMER}

#pragma once

namespace caf
{{
  template<class T> class Proxy;
}}
'''

flat_fwd_prolog = '''{DISCLAIMER}

#pragma once

namespace flat
{{
  template<class T> class Flat;
}}
'''

def fwd_prolog():
    return flat_fwd_prolog if gFlat else proxy_fwd_prolog

# -----------------------------------------------------------------------------
def fwd_body():
    return '''
namespace {NS}
{{
  class {TYPE};
  using {SHORTTYPE} = {PTYPE};
}}
'''

# -----------------------------------------------------------------------------

def emit(klass):
    # Shared
    proxy_inits = []
    flat_inits = []
    memlist = []
    # Proxy
    assign_body = []
    checkequals_body = []
    # Flat
    fill_body = []
    clear_body = []

    base = base_class(klass)
    if base:
        pbtype = proxy_type(base)
        proxy_inits += ['  {PBTYPE}(tr, name, base, offset)'.format(PBTYPE = pbtype)]
        flat_inits += ['  {PBTYPE}(tr, prefix, totsize, policy)'.format(PBTYPE = pbtype)]
        assign_body += ['  {PBTYPE}::operator=(sr);'.format(PBTYPE = pbtype)]
        checkequals_body += ['  {PBTYPE}::CheckEquals(sr);'.format(PBTYPE = pbtype)]
        fill_body += ['  {PBTYPE}::Fill(sr);'.format(PBTYPE = pbtype)]
        clear_body += ['  {PBTYPE}::Clear();'.format(PBTYPE = pbtype)]

    for v in members(klass):
        proxy_inits += [ '  {NAME}(tr, Join(name, "{NAME}"), base, offset)'.format(NAME = v.name)]
        flat_inits += [ '  {NAME}(tr, prefix+".{NAME}", totsize, policy)'.format(NAME = v.name)]

        memlist += ['  {PTYPE} {NAME};'.format(PTYPE = proxy_type(v.decl_type), NAME = v.name)]

        assign_body += ['  {NAME} = sr.{NAME};'.format(NAME = v.name)]
        checkequals_body += ['  {NAME}.CheckEquals(sr.{NAME});'.format(NAME = v.name)]

        fill_body += ['  {NAME}.Fill(sr.{NAME});'.format(NAME = v.name)]
        clear_body += ['  {NAME}.Clear();'.format(NAME = v.name)]


    inits = flat_inits if gFlat else proxy_inits

    fcxx.write(cxx_body().format(TYPE = full_name(klass),
                                 PTYPE = proxy_type(klass),
                                 INITS = ',\n'.join(inits),
                                 # For Proxy
                                 ASSIGN_BODY = '\n'.join(assign_body),
                                 CHECKEQUALS_BODY = '\n'.join(checkequals_body),
                                 # For Flat
                                 FILL_BODY = '\n'.join(fill_body),
                                 CLEAR_BODY = '\n'.join(clear_body)))

    ffwd.write(fwd_body().format(NS = full_namespace(klass),
                                 TYPE = klass.name,
                                 PTYPE = proxy_type(klass),
                                 SHORTTYPE = friendly_name(klass)))

    fhdr.write(hdr_body().format(TYPE = full_name(klass),
                                 PTYPE = proxy_type(klass),
                                 BASE = ' : public '+proxy_type(base) if base else '',
                                 ADDONS = class_to_addons[klass.name] if klass.name in class_to_addons else '',
                                 MEMBERS = '\n'.join(memlist)))


already = set()
def recurse(klass):
    if pygccxml.declarations.is_std_string(klass): return

    if klass in already: return
    already.add(klass)

    if is_vector(klass):
        recurse(vector_contents(klass))
        return

    if pygccxml.declarations.is_array(klass):
        recurse(array_contents(klass))
        return

    if not pygccxml.declarations.is_class(klass): return

    base = base_class(klass)
    if base: recurse(base)

    for v in members(klass):
        if is_vector(v.decl_type):
            recurse(vector_contents(v.decl_type))
        elif pygccxml.declarations.is_array(v.decl_type):
            recurse(array_contents(v.decl_type))
        elif pygccxml.declarations.is_class(v.decl_type):
            recurse(v.decl_type.declaration)

    emit(klass)


def makeParser():
    parser = argparse.ArgumentParser()

    parser.add_argument('--flat', action = 'store_true',
                        help = 'Generate classes for writing flat record structure, rather than proxy classes for reading')

    parser.add_argument('-i', '--input',
                        metavar = 'IN.h',
                        help = 'Input header (relative to --include-path)',
                        required = True)

    parser.add_argument('-o', '--output',
                        metavar = 'OUT',
                        help = 'Output file base name',
                        required = True)

    parser.add_argument('-t', '--target',
                        metavar = 'CLASS',
                        help = 'The name of the C++ type to be proxied',
                        required = True)

    parser.add_argument('-p', '--include-path',
                        metavar = 'PATH',
                        help = 'Colon-separated include path',
                        required = True)

    parser.add_argument('-op', '--output-path',
                        metavar = 'PATH',
                        help = 'Path for generated files to use to include each other',
                        required = True)

    parser.add_argument('--prolog',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the start of the generated header')

    parser.add_argument('--epilog',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the end of the generated header')

    parser.add_argument('--epilog-fwd',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the end of FwdDeclare.h')

    parser.add_argument('--extra',
                        metavar = ('CLASS', 'FILE'),
                        nargs = 2,
                        help = 'Include the contents of FILE in the declaration of the proxy for CLASS. Multiple allowed',
                        action = 'append')

    parser.add_argument('--extra-cflags',
                        metavar = 'FLAGS',
                        help = 'Extra options to pass to castxml compiler (in addition to -std=c++1z)',
                        default = '')

    return parser


def main():
    parser = makeParser()
    opts = vars(parser.parse_args())

    global gFlat
    gFlat = opts['flat']

    path = opts['include_path'].split(':')

    input_header = None
    for p in path:
        if os.path.isfile(p+'/'+opts['input']):
            input_header = p+'/'+opts['input']
            break

    if not input_header:
        print('Unable to find', opts['input'], 'in any of')
        for p in path: print('  '+p)
        sys.exit(1)


    target = opts['target'].split('::')

    # Locate the castxml executable
    generator_path, generator_name = pygccxml.utils.find_xml_generator()

    config = pygccxml.parser.xml_generator_configuration_t(
        xml_generator_path = generator_path,
        xml_generator = generator_name,
        include_paths = path,
        cflags = '-std=c++1z -Wno-unknown-warning-option '+opts['extra_cflags']
        )

    decls = pygccxml.parser.parse([input_header], config)

    top = pygccxml.declarations.get_global_namespace(decls)

    # Hack to support array_contents() function
    global global_ns
    global_ns = top

    while len(target) > 1:
        top = top.namespace(target[0])
        target = target[1:]

    top = top.class_(target[0])


    if opts['extra']:
        for e in opts['extra']:
            class_to_addons[e[0]] = open(e[1]).read()


    global fcxx, fhdr, ffwd
    fcxx = open(opts['output']+'.cxx', 'w')
    fhdr = open(opts['output']+'.h', 'w')
    ffwd = open('FwdDeclare.h', 'w')

    fcxx.write(cxx_prolog().format(DISCLAIMER = disclaimer(),
                                   INPUT = opts['input'],
                                   HEADER = opts['output_path']+'/'+opts['output']+'.h'))

    prolog = open(opts['prolog']).read() if opts['prolog'] else ''
    fhdr.write(hdr_prolog().format(DISCLAIMER = disclaimer(),
                                   PROLOG = prolog,
                                   OUTPATH = opts['output_path']))

    ffwd.write(fwd_prolog().format(DISCLAIMER = disclaimer()))

    recurse(top)

    if opts['epilog']: fhdr.write(open(opts['epilog']).read())

    if opts['epilog_fwd']: ffwd.write(open(opts['epilog_fwd']).read())

    print('Wrote '+fhdr.name+', '+ffwd.name+', '+fcxx.name)


if __name__ == '__main__':
    main()
